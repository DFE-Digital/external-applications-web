@using Microsoft.AspNetCore.Html;
@using System.Text.Json;
@using DfE.ExternalApplications.Application.Interfaces;
@using DfE.ExternalApplications.Domain.Models;
@inject IComplexFieldConfigurationService ComplexFieldConfigurationService
@model DfE.ExternalApplications.Web.Services.FieldViewModel

@{
    var isRequired = Model.Field.Required ?? true;
    var validationAttributes = new HtmlString(Model.ValidationAttributes);
    var labelClasses = Model.Field.Label.IsVisible ? "govuk-label" : "govuk-visually-hidden";
    var label = Model.Field.Label.Value;
    
    // Get the complex field ID from the ComplexField object
    var complexFieldId = Model.Field.ComplexField?.Id ?? "";
    
    // Get configuration from appsettings
    var configuration = ComplexFieldConfigurationService.GetConfiguration(complexFieldId);
    
    // Generate unique IDs
    var inputId = $"{Model.Id}-complex-field";
    
    // Get current value for initial display
    var currentValue = Model.CurrentValue;
    var displayValue = "";
    
    if (!string.IsNullOrEmpty(currentValue))
    {
        try
        {
            // Try to parse as JSON and extract the name
            using (var doc = JsonDocument.Parse(currentValue))
            {
                if (doc.RootElement.ValueKind == JsonValueKind.Object)
                {
                    if (doc.RootElement.TryGetProperty("name", out var nameElement))
                    {
                        displayValue = nameElement.GetString() ?? "";
                    }
                }
                else if (doc.RootElement.ValueKind == JsonValueKind.Array && doc.RootElement.GetArrayLength() > 0)
                {
                    var firstElement = doc.RootElement[0];
                    if (firstElement.ValueKind == JsonValueKind.Object && firstElement.TryGetProperty("name", out var nameElement))
                    {
                        displayValue = nameElement.GetString() ?? "";
                    }
                }
            }
        }
        catch
        {
            // If not JSON, use as is
            displayValue = currentValue;
        }
    }
}

@if (string.IsNullOrEmpty(complexFieldId))
{
    <div class="govuk-form-group govuk-form-group--error">
        <govuk-error-message>Complex field configuration is missing or invalid</govuk-error-message>
    </div>
}
else
{
    <div class="govuk-form-group @(string.IsNullOrEmpty(Model.ErrorMessage) ? "" : "govuk-form-group--error")">
        @if (!string.IsNullOrEmpty(Model.Field.Label.Value))
        {
            <label id="@label-label" class="@labelClasses" for="@inputId">
                @label
                @if (isRequired)
                {
                    <span class="govuk-visually-hidden">required</span>
                }
            </label>
        }
        
        @if (!string.IsNullOrEmpty(Model.Field.Tooltip))
        {
            <div class="govuk-hint">@Model.Field.Tooltip</div>
        }
        
        @if (!string.IsNullOrEmpty(Model.ErrorMessage))
        {
            <div class="govuk-error-message">@Model.ErrorMessage</div>
        }
        
        <div class="complex-field-container" data-module="autocomplete-complex-field" data-field-type="autocomplete">
            <!-- Hidden input for form submission -->
            <input type="hidden" 
                   id="@Model.Id" 
                   name="Data[@Model.Id]" 
                   value="@Model.CurrentValue" 
                   data-allow-multiple="@configuration.AllowMultiple.ToString().ToLower()" />

        @{
            var ariaLabel = !string.IsNullOrEmpty(Model.Field.Label.Value) ? label + "-label" : "page-title";
        }
            
            <!-- Container for autocomplete - library will create input here -->
            <div id="@inputId-container" 
                 class="complex-field-search-container"
                 data-complex-field-id="@complexFieldId"
                 data-min-length="@configuration.MinLength"
                 data-allow-multiple="@configuration.AllowMultiple.ToString().ToLower()"
                 data-target-input="@Model.Id"
                 data-placeholder="@configuration.Placeholder"
                 data-display-value="@displayValue"
                 aria-describedby="@inputId-hint"
                 aria-labelledby="@ariaLabel">
                 
                 <!-- Fallback input in case accessible-autocomplete fails -->
                 <input type="text" 
                        id="@inputId-fallback" 
                        class="govuk-input" 
                        placeholder="@configuration.Placeholder"
                        value="@displayValue"
                        style="display: none;" />
             </div>
            
            <div id="@inputId-hint" class="govuk-visually-hidden">
                Use this field to search and select options. Type at least @configuration.MinLength characters to see results.
                @(configuration.AllowMultiple ? "<span>You can select multiple options.</span>" : "")
            </div>
        </div>
    </div>
}

<style>
    .complex-field-container {
        position: relative;
    }
    
    .complex-field-search-containser {
        position: relative;
    }
    
    /* Custom autocomplete suggestion styling */
    .complex-field-suggestion {
        padding: 2px 0;
    }
    
    .complex-field-suggestion-name {
        font-weight: 400;
        color: #0b0c0c;
        line-height: 1.2;
    }
    
    .complex-field-suggestion-identifiers {
        font-size: 16px;
        color: #6f777b;
        font-weight: 400;
        margin-top: 2px;
        line-height: 1.2;
    }
    
    /* Accessible autocomplete styling overrides */
    .autocomplete__wrapper {
        position: relative;
    }
    
    .autocomplete__input {
        border: 2px solid #0b0c0c;
        border-radius: 0;
        box-sizing: border-box;
        font-family: "GDS Transport", arial, sans-serif;
        font-size: 16px;
        font-weight: 400;
        line-height: 1.25;
        padding: 5px 4px 4px;
        width: 100%;
        background-color: #ffffff;
        color: #0b0c0c;
    }
    
    .autocomplete__input:focus {
        outline: 3px solid #ffdd00;
        outline-offset: 0;
        box-shadow: inset 0 0 0 2px;
    }
    
    /* Error state styling */
    .govuk-form-group--error .autocomplete__input {
        border-color: #d4351c;
    }
    
    .autocomplete__menu {
        background-color: #ffffff;
        border: 2px solid #0b0c0c;
        border-top: 0;
        color: #0b0c0c;
        margin: 0;
        max-height: 342px;
        overflow-x: hidden;
        overflow-y: auto;
        padding: 0;
        width: 100%;
        z-index: 100;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .autocomplete__option {
        border-bottom: solid #b1b4b6;
        border-width: 1px 0;
        cursor: pointer;
        display: block;
        position: relative;
        padding: 10px;
        font-family: "GDS Transport", arial, sans-serif;
        font-size: 16px;
        font-weight: 400;
        line-height: 1.25;
        color: #0b0c0c;
    }
    
    .autocomplete__option > * {
        pointer-events: none;
    }
    
    .autocomplete__option:focus,
    .autocomplete__option:hover {
        background-color: #1d70b8;
        border-color: #1d70b8;
        color: #ffffff !important;
    }
    
    .autocomplete__option--odd {
        background-color: #fafafa;
    }
    
    .autocomplete__option--focused,
    .autocomplete__option--selected {
        background-color: #1d70b8;
        border-color: #1d70b8;
        color: #ffffff !important;
    }
    
    /* Ensure text color changes for all states */
    .autocomplete__option:focus *,
    .autocomplete__option:hover * {
        color: #ffffff !important;
    }
    
    .autocomplete__option--focused *,
    .autocomplete__option--selected * {
        color: #ffffff !important;
    }
    
    .autocomplete__hint {
        color: #6f777b;
        position: absolute;
        right: 0;
        top: 0;
    }
</style>

<script>
// Global escapeHtml function for templates - defined at the top to avoid "not defined" errors
window.escapeHtml = function(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, function(m) { return map[m]; });
};

document.addEventListener('DOMContentLoaded', function() {
    // Test if accessible-autocomplete is available
    console.log('DOM loaded. Testing accessible-autocomplete...');
    console.log('accessibleAutocomplete:', typeof accessibleAutocomplete);
    console.log('accessibleAutocomplete object:', accessibleAutocomplete);
    
    // Check if the library is loaded from CDN
    if (typeof accessibleAutocomplete === 'undefined') {
        console.error('accessibleAutocomplete library is NOT loaded!');
        console.error('Check if the CDN script is loading correctly in _Layout.cshtml');
        
        // Show all fallback inputs immediately since library is not available
        const fallbackInputs = document.querySelectorAll('[id$="-fallback"]');
        console.log('Found fallback inputs:', fallbackInputs.length);
        fallbackInputs.forEach(function(input) {
            input.style.display = 'block';
            console.log('Showing fallback input:', input.id);
            
            // Make fallback inputs functional for search
            const container = input.closest('[data-module="autocomplete-complex-field"]');
            if (container) {
                const complexFieldContainer = container.querySelector('[data-complex-field-id]');
                const hiddenInput = container.querySelector('input[type="hidden"]');
                const complexFieldId = complexFieldContainer?.dataset.complexFieldId;
                const minLength = parseInt(complexFieldContainer?.dataset.minLength) || 3;
                
                console.log('Setting up fallback input for complex field:', complexFieldId);
                
                // Add search functionality to fallback input
                let searchTimeout;
                input.addEventListener('input', function(e) {
                    const query = e.target.value;
                    console.log('Fallback input changed:', query);
                    
                    // Clear previous timeout
                    if (searchTimeout) {
                        clearTimeout(searchTimeout);
                    }
                    
                    // Update hidden input
                    hiddenInput.value = query;
                    
                    // Search if query is long enough
                    if (query && query.length >= minLength) {
                        console.log('Triggering search for query:', query);
                        
                        // Debounce the search
                        searchTimeout = setTimeout(function() {
                            performSearch(complexFieldId, query, input);
                        }, 300);
                    }
                });
            }
        });
        
        // Function to perform search
        function performSearch(complexFieldId, query, inputElement) {
            console.log('Performing search for:', query, 'in complex field:', complexFieldId);
            
            const requestUrl = window.location.pathname + '?handler=complexField&complexFieldId=' + encodeURIComponent(complexFieldId) + '&query=' + encodeURIComponent(query);
            console.log('Making API call to:', requestUrl);
            
            fetch(requestUrl)
                .then(response => {
                    console.log('Search API response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('Search results:', data);
                    
                    // Show results in a dropdown
                    showSearchResults(data, inputElement);
                })
                .catch(error => {
                    console.error('Search API error:', error);
                });
        }
        
        // Function to show search results in a dropdown
        function showSearchResults(results, inputElement) {
            // Remove existing dropdown
            const existingDropdown = inputElement.parentNode.querySelector('.search-results-dropdown');
            if (existingDropdown) {
                existingDropdown.remove();
            }
            
            if (!Array.isArray(results) || results.length === 0) {
                console.log('No search results to show');
                return;
            }
            
            console.log('Showing', results.length, 'search results');
            
            // Create dropdown
            const dropdown = document.createElement('div');
            dropdown.className = 'search-results-dropdown';
            dropdown.style.cssText = `
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: white;
                border: 2px solid #0b0c0c;
                border-top: none;
                max-height: 200px;
                overflow-y: auto;
                z-index: 1000;
                box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            `;
            
            // Add results
            results.forEach((result, index) => {
                const resultItem = document.createElement('div');
                resultItem.className = 'search-result-item';
                resultItem.style.cssText = `
                    padding: 10px;
                    border-bottom: 1px solid #b1b4b6;
                    cursor: pointer;
                    font-family: "GDS Transport", arial, sans-serif;
                    font-size: 16px;
                `;
                
                // Handle different result types
                let displayText = '';
                if (typeof result === 'object' && result !== null && result.name) {
                    displayText = result.name;
                    const parts = [];
                    if (result.ukprn) { parts.push(`UKPRN: ${result.ukprn}`); }
                    if (result.companiesHouseNumber) { parts.push(`Companies House: ${result.companiesHouseNumber}`); }
                    if (parts.length > 0) {
                        displayText += ' - ' + parts.join(' - ');
                    }
                } else if (typeof result === 'string') {
                    displayText = result;
                } else {
                    displayText = JSON.stringify(result);
                }
                
                resultItem.textContent = displayText;
                
                // Add hover effect
                resultItem.addEventListener('mouseenter', function() {
                    this.style.backgroundColor = '#f8f9fa';
                });
                
                resultItem.addEventListener('mouseleave', function() {
                    this.style.backgroundColor = 'white';
                });
                
                // Add click handler
                resultItem.addEventListener('click', function() {
                    console.log('Result selected:', result);
                    
                    // Update the input with the selected result
                    if (typeof result === 'object' && result !== null && result.name) {
                        inputElement.value = result.name;
                    } else {
                        inputElement.value = result.toString();
                    }
                    
                    // Update hidden input with JSON
                    const container = inputElement.closest('[data-module="autocomplete-complex-field"]');
                    const hiddenInput = container.querySelector('input[type="hidden"]');
                    hiddenInput.value = JSON.stringify(result);
                    
                    console.log('Updated hidden input with:', hiddenInput.value);
                    
                    // Hide dropdown
                    dropdown.remove();
                });
                
                dropdown.appendChild(resultItem);
            });
            
            // Insert dropdown after input
            inputElement.parentNode.appendChild(dropdown);
            
            // Close dropdown when clicking outside
            document.addEventListener('click', function closeDropdown(e) {
                if (!dropdown.contains(e.target) && e.target !== inputElement) {
                    dropdown.remove();
                    document.removeEventListener('click', closeDropdown);
                }
            });
        }
        
        // Add a visible error message to the page
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = 'background-color: #f8d7da; color: #721c24; padding: 10px; margin: 10px 0; border: 1px solid #f5c6cb; border-radius: 4px;';
        errorDiv.innerHTML = '<strong>Warning:</strong> The autocomplete library failed to load. Using fallback input field.';
        document.body.insertBefore(errorDiv, document.body.firstChild);
        
        return;
    }
    
    console.log('accessibleAutocomplete library is available, proceeding with initialization');
    
    // Ensure fallback inputs are hidden when library is available
    const fallbackInputs = document.querySelectorAll('[id$="-fallback"]');
    fallbackInputs.forEach(function(input) {
        input.style.display = 'none';
        console.log('Hiding fallback input:', input.id, 'since accessible-autocomplete is available');
    });
    
    // Initialize autocomplete complex field functionality
    const containers = document.querySelectorAll('[data-module="autocomplete-complex-field"]');
    console.log('Found autocomplete complex field containers:', containers.length);
    
    containers.forEach(function(container) {
        // Check if this container has already been initialized
        if (container.dataset.initialized === 'true') {
            console.log('Container already initialized, skipping...');
            return;
        }
        
        console.log('Processing container:', container);
        console.log('Container HTML:', container.outerHTML);
        
        const complexFieldContainer = container.querySelector('[data-complex-field-id]');
        const hiddenInput = container.querySelector('input[type="hidden"]');
        const complexFieldId = complexFieldContainer.dataset.complexFieldId;
        const fieldId = hiddenInput.id; // Use the actual field ID for form submission
        const allowMultiple = complexFieldContainer.dataset.allowMultiple === 'true';
        
        console.log('Container found:', container);
        console.log('Complex field container found:', complexFieldContainer);
        console.log('Hidden input found:', hiddenInput);
        console.log('Complex field ID:', complexFieldId);
        console.log('Field ID:', fieldId);
        console.log('Allow multiple:', allowMultiple);
        
        // Extract the actual field ID without the "Data_" prefix
        const actualFieldId = fieldId.startsWith('Data_') ? fieldId.substring(5) : fieldId;
        
        console.log('Field ID for form submission:', fieldId);
        console.log('Actual field ID (without Data_ prefix):', actualFieldId);
        console.log('Hidden input name:', hiddenInput.name);
        console.log('Hidden input value:', hiddenInput.value);
        const minLength = parseInt(complexFieldContainer.dataset.minLength) || 3;
        const placeholder = complexFieldContainer.dataset.placeholder;
        const displayValue = complexFieldContainer.dataset.displayValue || '';
        
        console.log('Initializing autocomplete complex field for container element:', complexFieldContainer);
        console.log('Complex Field ID:', complexFieldId);
        console.log('Placeholder:', placeholder);
        console.log('Display Value:', displayValue);
        
        // Initialize accessible autocomplete on the container element
        console.log('Checking if accessibleAutocomplete is available...');
        console.log('Type of accessibleAutocomplete:', typeof accessibleAutocomplete);
        console.log('accessibleAutocomplete object:', accessibleAutocomplete);
        
        if (typeof accessibleAutocomplete !== 'undefined') {
            try {
                console.log('Initializing accessible-autocomplete for autocomplete complex field');
                console.log('Container element:', complexFieldContainer);
                console.log('Container ID:', complexFieldContainer.id);
                console.log('Display value:', displayValue);
                
                accessibleAutocomplete({
                    element: complexFieldContainer,
                    id: complexFieldContainer.id,
                    placeholder: placeholder, // Always show placeholder
                    showAllValues: false,
                    autoselect: false, // Don't auto-select to avoid unwanted value display
                    confirmOnBlur: false,
                    defaultValue: '', // Keep empty
                    displayMenu: 'overlay',
                    preserveNull: true,
                    allowEmpty: true,
                    onConfirm: function(option) {
                        console.log('OnConfirm function triggered!');
                        console.log('Option confirmed:', option);
                        console.log('Option type:', typeof option);
                        console.log('Option details:', JSON.stringify(option));
                        
                        if (option) {
                            var isValidString = typeof option === 'string' && option.trim() !== '';
                            var isValidObject = typeof option === 'object' && option !== null && option.name;
                            
                            console.log('Is valid string:', isValidString);
                            console.log('Is valid object:', isValidObject);
                            
                            if (isValidString || isValidObject) {
                                console.log('Option selected, updating hidden input');
                                
                                // Update the hidden input with the selected value
                                if (allowMultiple) {
                                    // For multiple selection, append to existing array
                                    const currentValue = hiddenInput.value;
                                    let values = [];
                                    if (currentValue) {
                                        try {
                                            values = JSON.parse(currentValue);
                                            if (!Array.isArray(values)) {
                                                values = [values];
                                            }
                                        } catch {
                                            values = [currentValue];
                                        }
                                    }
                                    
                                    // Check if value already exists
                                    const exists = values.some(v => 
                                        (typeof v === 'object' && typeof option === 'object' && v.name === option.name) ||
                                        (typeof v === 'string' && typeof option === 'string' && v === option)
                                    );
                                    
                                    if (!exists) {
                                        values.push(option);
                                        hiddenInput.value = JSON.stringify(values);
                                        console.log('Added to multiple selection, total values:', values.length);
                                    } else {
                                        console.log('Value already selected, skipping');
                                    }
                                } else {
                                    // For single selection, replace the value
                                    hiddenInput.value = JSON.stringify(option);
                                    console.log('Single selection updated');
                                }
                                
                                console.log('Hidden input value updated to:', hiddenInput.value);
                            } else {
                                console.log('Option validation failed');
                            }
                        } else {
                            console.log('No option provided to onConfirm');
                        }
                    },
                    templates: {
                        inputValue: function(result) {
                            console.log('inputValue template called with:', result);
                            
                            // Show the selected value in the input when confirmed
                            if (result && typeof result === 'object' && result !== null && result.name) {
                                var displayText = result.name;
                                var parts = [];
                                
                                if (result.ukprn) {
                                    parts.push('UKPRN: ' + result.ukprn);
                                }
                                if (result.companiesHouseNumber) {
                                    parts.push('Companies House Number: ' + result.companiesHouseNumber);
                                }
                                
                                if (parts.length > 0) {
                                    displayText += ' - ' + parts.join(' - ');
                                }
                                
                                return displayText;
                            }
                            
                            // Return empty string for initial load or when no result
                            return '';
                        },
                        suggestion: function(result) {
                            console.log('suggestion template called with:', result);
                            if (typeof result === 'object' && result !== null && result.name) {
                                var html = '<div class="complex-field-suggestion">';
                                html += '<div class="complex-field-suggestion-name">' + escapeHtml(result.name) + '</div>';
                                
                                var parts = [];
                                if (result.ukprn) {
                                    parts.push('UKPRN: ' + escapeHtml(result.ukprn));
                                }
                                if (result.companiesHouseNumber) {
                                    parts.push('Companies House: ' + escapeHtml(result.companiesHouseNumber));
                                }
                                if (parts.length > 0) {
                                    html += '<div class="complex-field-suggestion-identifiers">' + parts.join(' - ') + '</div>';
                                }
                                
                                html += '</div>';
                                return html;
                            }
                            return result ? escapeHtml(result.toString()) : '';
                        }
                    },
                    source: function(query, populateResults) {
                        console.log('Source called with query:', query);
                        console.log('Query length:', query.length, 'Min length:', minLength);
                        
                        // If query is empty or too short, don't show any results
                        if (!query || query.length < minLength) {
                            console.log('Query too short, returning empty results');
                            populateResults([]);
                            return;
                        }
                        
                        // Use the complex field ID for the API call
                        var requestUrl = window.location.pathname + '?handler=complexField&complexFieldId=' + encodeURIComponent(complexFieldId) + '&query=' + encodeURIComponent(query);
                        console.log('Making API call to:', requestUrl);
                        
                        // Make API call to the endpoint
                        fetch(requestUrl)
                            .then(response => {
                                console.log('API response status:', response.status);
                                console.log('API response ok:', response.ok);
                                return response.json();
                            })
                            .then(data => {
                                console.log('Raw API response:', data);
                                // The service now returns a simple array of objects or strings
                                var results = Array.isArray(data) ? data : [];
                                console.log('Results before filtering:', results);
                                // Filter out empty values
                                results = results.filter(function(item) {
                                    if (typeof item === 'object' && item !== null) {
                                        return item.name && item.name.toString().trim() !== '';
                                    }
                                    return item && item.toString().trim() !== '';
                                });
                                console.log('Final filtered results:', results);
                                populateResults(results);
                            })
                            .catch(error => {
                                console.error('Complex field API error:', error);
                                populateResults([]);
                            });
                    },
                    minLength: minLength,
                });
                
                console.log('Autocomplete complex field initialized successfully');
                
                // Mark this container as initialized
                container.dataset.initialized = 'true';
                
                // Monitor form submission to track data preservation
                const form = container.closest('form');
                if (form) {
                    form.addEventListener('submit', function(e) {
                        console.log('Form submission detected');
                        console.log('Hidden input value before submission:', hiddenInput.value);
                        
                        // Log all form data
                        const formData = new FormData(form);
                        console.log('Form data being submitted:');
                        for (let [key, value] of formData.entries()) {
                            console.log('  ', key, ':', value);
                        }
                    });
                    
                    console.log('Added form submission monitoring');
                }
                
                // Apply GovUK styling to the created input after a short delay
                setTimeout(function() {
                    const autocompleteInput = container.querySelector('.autocomplete__input');
                    if (autocompleteInput) {
                        // Set the correct ID to match the label's 'for' attribute
                        autocompleteInput.id = fieldId + '-complex-field';
                        autocompleteInput.classList.add('govuk-input');
                        if (container.closest('.govuk-form-group--error')) {
                            autocompleteInput.classList.add('govuk-input--error');
                        }
                        console.log('Applied GovUK styling to autocomplete complex field input');
                        console.log('Set input ID to:', autocompleteInput.id);
                        
                        // Add event listener to clear selection when user starts typing
                        autocompleteInput.addEventListener('input', function(e) {
                            const currentValue = e.target.value;
                            console.log('Input changed to:', currentValue);
                            
                            // If the user is typing something different from what was selected,
                            // clear the hidden input to trigger new searches
                            if (currentValue && currentValue.trim() !== '') {
                                // User is typing, clear the selection to allow new searches
                                if (hiddenInput.value) {
                                    console.log('User started typing, clearing current selection');
                                    hiddenInput.value = '';
                                }
                            }
                        });
                        
                        // Add blur event listener to handle when input is completely cleared
                        autocompleteInput.addEventListener('blur', function(e) {
                            const currentValue = e.target.value;
                            console.log('Input blur, current value:', currentValue);
                            
                            // If the input is completely empty, ensure placeholder is visible
                            if (!currentValue || currentValue.trim() === '') {
                                console.log('Input is empty, ensuring placeholder is visible');
                                // The accessible-autocomplete library should automatically show placeholder
                                // when the input is empty
                            }
                        });
                    }
                }, 100);
                
            } catch (error) {
                console.error('Error initializing accessible-autocomplete for autocomplete complex field:', error);
                console.error('Error details:', error.message, error.stack);
            }
        } else {
            console.error('accessibleAutocomplete is not available');
            
            // Show fallback input if accessible-autocomplete is not available
            const fallbackInput = container.querySelector('#@inputId-fallback');
            if (fallbackInput) {
                fallbackInput.style.display = 'block';
                console.log('Showing fallback input');
                
                // Add event listener to update hidden input when fallback input changes
                fallbackInput.addEventListener('input', function(e) {
                    hiddenInput.value = e.target.value;
                    console.log('Fallback input changed, updated hidden input to:', e.target.value);
                });
            } else {
                console.log('Fallback input not found, creating a simple input manually');
                
                // Create a simple input field manually as a last resort
                const simpleInput = document.createElement('input');
                simpleInput.type = 'text';
                simpleInput.className = 'govuk-input';
                simpleInput.placeholder = placeholder || 'Search...';
                simpleInput.value = displayValue || '';
                simpleInput.style.width = '100%';
                
                // Add event listener
                simpleInput.addEventListener('input', function(e) {
                    hiddenInput.value = e.target.value;
                    console.log('Simple input changed, updated hidden input to:', e.target.value);
                });
                
                // Insert the input into the container
                complexFieldContainer.appendChild(simpleInput);
                console.log('Created and inserted simple input field');
            }
        }
        
        // Apply GovUK styling to the created input after a short delay
    });
});
</script> 