using System.Security.Claims;
using DfE.ExternalApplications.Application.Interfaces;
using GovUK.Dfe.CoreLibs.Contracts.ExternalApplications.Enums;
using GovUK.Dfe.ExternalApplications.Api.Client.Contracts;

namespace DfE.ExternalApplications.Web.Middleware;

/// <summary>
/// Middleware that checks for malware notifications and automatically cleans up infected files
/// </summary>
public class MalwareNotificationMiddleware(
    RequestDelegate next,
    ILogger<MalwareNotificationMiddleware> logger)
{
    // Cache to avoid checking too frequently
    private static readonly SemaphoreSlim Semaphore = new(1, 1);
    private static readonly Dictionary<string, DateTime> UserLastCheck = new();
    private static readonly TimeSpan CheckInterval = TimeSpan.FromSeconds(10);
    private static readonly object CacheLock = new();

    public async Task InvokeAsync(
        HttpContext context,
        INotificationsClient notificationsClient,
        IFileCleanupService fileCleanupService)
    {
        // Only check for authenticated users
        if (context.User.Identity?.IsAuthenticated == true)
        {
            var userId = context.User?.FindFirst(ClaimTypes.Email)?.Value
                         ?? context.User?.FindFirst("email")?.Value
                         ?? context.User?.FindFirst("sub")?.Value
                         ?? context.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value
                         ?? context.User?.Identity?.Name;

            if (ShouldCheckForMalware(userId))
            {
                // Try to acquire lock without blocking the request
                if (await Semaphore.WaitAsync(0))
                {
                    try
                    {
                        await CheckAndCleanMalwareNotificationsAsync(
                            notificationsClient,
                            fileCleanupService,
                            context.Session,
                            userId);
                        
                        UpdateLastCheckTime(userId);
                    }
                    catch (Exception ex)
                    {
                        logger.LogError(ex, "Error checking for malware notifications for user {UserId}", userId);
                    }
                    finally
                    {
                        Semaphore.Release();
                    }
                }
            }
        }

        // Continue to next middleware
        await next(context);
    }

    private bool ShouldCheckForMalware(string userId)
    {
        lock (CacheLock)
        {
            if (!UserLastCheck.TryGetValue(userId, out var lastCheck))
                return true;

            return DateTime.UtcNow - lastCheck > CheckInterval;
        }
    }

    private void UpdateLastCheckTime(string userId)
    {
        lock (CacheLock)
        {
            UserLastCheck[userId] = DateTime.UtcNow;
            
            // Clean up old entries (users who haven't been checked in 5 minutes)
            if (UserLastCheck.Count > 100)
            {
                var cutoff = DateTime.UtcNow.AddMinutes(-5);
                var oldKeys = UserLastCheck.Where(kvp => kvp.Value < cutoff).Select(kvp => kvp.Key).ToList();
                foreach (var key in oldKeys)
                {
                    UserLastCheck.Remove(key);
                }
            }
        }
    }

    private async Task CheckAndCleanMalwareNotificationsAsync(
        INotificationsClient notificationsClient,
        IFileCleanupService fileCleanupService,
        ISession session,
        string userId)
    {
        try
        {
            logger.LogDebug("Checking for malware notifications for user {UserId}", userId);

            // Get ALL notifications (including read ones) to ensure we catch any missed cleanups
            var notifications = await notificationsClient.GetAllNotificationsAsync(CancellationToken.None);

            if (notifications == null || notifications.Count == 0)
            {
                logger.LogDebug("No notifications found for user {UserId}", userId);
                return;
            }

            logger.LogDebug("Found {Count} total notifications for user {UserId}", notifications.Count, userId);

            // Check each notification for malware
            foreach (var notification in notifications)
            {
                if (IsMalwareNotification(notification))
                {
                    logger.LogWarning(
                        "Malware notification detected: NotificationId={NotificationId}, FileId={FileId}, FileName={FileName}",
                        notification.Id,
                        notification.Metadata?.GetValueOrDefault("fileId"),
                        notification.Metadata?.GetValueOrDefault("fileName"));

                    await ProcessMalwareNotificationAsync(notification, fileCleanupService, session);
                }
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error processing malware notifications for user {UserId}", userId);
        }
    }

    private bool IsMalwareNotification(GovUK.Dfe.CoreLibs.Contracts.ExternalApplications.Models.Response.NotificationDto notification)
    {
        try
        {
            // Check if it's a warning notification
            if (notification.Type != NotificationType.Warning)
            {
                return false;
            }

            // Check if metadata exists
            if (notification.Metadata == null || notification.Metadata.Count == 0)
            {
                return false;
            }

            // Check for required malware detection fields
            var hasFileId = notification.Metadata.ContainsKey("fileId") && 
                           notification.Metadata["fileId"] != null &&
                           !string.IsNullOrWhiteSpace(notification.Metadata["fileId"].ToString());

            var hasFileName = notification.Metadata.ContainsKey("fileName") && 
                             notification.Metadata["fileName"] != null &&
                             !string.IsNullOrWhiteSpace(notification.Metadata["fileName"].ToString());

            var hasMalwareName = notification.Metadata.ContainsKey("malwareName") && 
                                notification.Metadata["malwareName"] != null &&
                                !string.IsNullOrWhiteSpace(notification.Metadata["malwareName"].ToString());

            var hasApplicationId = notification.Metadata.ContainsKey("applicationId") && 
                                  notification.Metadata["applicationId"] != null &&
                                  !string.IsNullOrWhiteSpace(notification.Metadata["applicationId"].ToString());

            var isMalware = hasFileId && hasFileName && hasMalwareName && hasApplicationId;

            if (isMalware)
            {
                logger.LogDebug(
                    "Notification {NotificationId} identified as malware notification: FileId={FileId}, FileName={FileName}, MalwareName={MalwareName}",
                    notification.Id,
                    notification.Metadata["fileId"],
                    notification.Metadata["fileName"],
                    notification.Metadata["malwareName"]);
            }

            return isMalware;
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error checking if notification {NotificationId} is malware", notification.Id);
            return false;
        }
    }

    private async Task ProcessMalwareNotificationAsync(
        GovUK.Dfe.CoreLibs.Contracts.ExternalApplications.Models.Response.NotificationDto notification,
        IFileCleanupService fileCleanupService,
        ISession session)
    {
        try
        {var fileIdStr = notification.Metadata!["fileId"].ToString();
            var fileName = notification.Metadata["fileName"].ToString();
            var applicationIdStr = notification.Metadata["applicationId"].ToString();
            var malwareName = notification.Metadata["malwareName"].ToString();

            if (!Guid.TryParse(fileIdStr, out var fileId))
            {
                logger.LogWarning("Invalid fileId in malware notification: {FileId}", fileIdStr);
                return;
            }

            if (!Guid.TryParse(applicationIdStr, out var applicationId))
            {
                logger.LogWarning("Invalid applicationId in malware notification: {ApplicationId}", applicationIdStr);
                return;
            }

            logger.LogWarning(
                "Processing malware notification: FileId={FileId}, FileName={FileName}, ApplicationId={ApplicationId}, MalwareName={MalwareName}",
                fileId, fileName, applicationId, malwareName);

            // Call the cleanup service
            var success = await fileCleanupService.RemoveInfectedFileAsync(
                applicationId,
                fileId,
                fileName!,
                session);

            if (success)
            {
                logger.LogInformation(
                    "Successfully cleaned up infected file {FileId} ({FileName}) from application {ApplicationId} via middleware",
                    fileId, fileName, applicationId);
            }
            else
            {
                logger.LogWarning(
                    "Failed to clean up infected file {FileId} from application {ApplicationId} via middleware",
                    fileId, applicationId);
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex,
                "Error processing malware notification {NotificationId}",
                notification.Id);
        }
    }
}

